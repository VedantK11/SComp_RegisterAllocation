//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

import javax.naming.spi.DirStateFactory.Result;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class GJDepthFirst_v1<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //

   //symbol talbe to store the variables for each and every method
   //{Classname, {Methodname, {Varname, {startpoint, endpoint}}}}
   public static HashMap<String, HashMap<String, HashMap<String,HashMap<Integer,Integer>>>> symbolTable = new HashMap<String, HashMap<String, HashMap<String,HashMap<Integer,Integer>>>>();

   //table to store the variables for each and every method with thier type
   //{Classname, {Methodname, {Varname, Type}}}
   public static HashMap<String, HashMap<String, HashMap<String,String>>> symbolTableType = new HashMap<String, HashMap<String, HashMap<String,String>>>();

   //stack to store current class 
   public static Stack<String> currentClass = new Stack<String>();
   
   //stack to store current method
   public static Stack<String> currentMethod = new Stack<String>();

   //int to store the given reg limit
   public static int regLimit = 0;

   //HashMap to store the unique registers used
   public static HashMap<String, HashMap<String, Integer>> uniqueRegisters = new HashMap<String, HashMap<String, Integer>>();

   //list of string to store the total registers
   // public static List<String> Registers = new ArrayList<String>();
   //HashMap with register index and flag to check if the register is free or not
   public static HashMap<Integer, Boolean> Register = new HashMap<Integer, Boolean>();
   
   int programPoint = 1;
   HashMap<Node, Set<String>> resultMap;

   private String getTypeName(Type t) {
      if (t.f0.choice instanceof Identifier) {
         return ((Identifier) t.f0.choice).f0.tokenImage;  
      } else if (t.f0.choice instanceof IntegerType) {
         return "int";  
      } else if (t.f0.choice instanceof BooleanType) {
         return "boolean";
      }else if (t.f0.choice instanceof FloatType) {
         return "float"; 
      }
      return "unknown";  // Fallback
   }

   //class to store the variabl and live interval
   public static class Variable{
      String varName;
      int start;
      int end;
      int allocatedReg;
      String type;
      public Variable(String varName, int start, int end){
         this.varName = varName;
         this.start = start;
         this.end = end;
      }
   }
   
   //Deque to store the active list
   // Deque<Variable> active = new ArrayDeque<Variable>();
   public static List<Variable> active = new ArrayList<Variable>();

   
   //HashMap to store the list of active in the increasing order of end point
   public static HashMap<String, HashMap<String, List<Variable>>> activeListSortedEndInt = new HashMap<String, HashMap<String, List<Variable>>>();
   
   //List to store the variables live interval
   public static HashMap<String, HashMap<String, List<Variable>>> liveInterval = new HashMap<String, HashMap<String, List<Variable>>>();
   
   
   public static class RegisterVariable {
      String varName;
      int start;
      int end;
      int regAlloc;
      public RegisterVariable(String variable, int start, int end, int regAlloc) {
         this.varName = variable;
         this.start = start;
         this.end = end;
         this.regAlloc = regAlloc;
      }
   };

   //list of Registere allocated variables
   public static HashMap<String, HashMap<String, ArrayList<RegisterVariable>>> registerAllocatedVariables = new HashMap<String, HashMap<String, ArrayList<RegisterVariable>>>();

   public static class SpilledVariable {
      String varName;
      int start;
      int end;
      int spillLocation;
      String type;
      public SpilledVariable(String variable, int start, int end, int spillLocation, String type) {
         this.varName = variable;
         this.start = start;
         this.end = end;
         this.spillLocation = spillLocation;
         this.type = type;
      }
};

   //list of spilled variables
   public static HashMap<String, HashMap<String, ArrayList<SpilledVariable>>> spilledVariables = new HashMap<String, HashMap<String, ArrayList<SpilledVariable>>>();

   //list of register allocated variables

   //funct to check if the variable is spilled 
   public boolean isSpilled(String variable){
      if (spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).contains(variable)){
         return true;
      }
      return false;
   }


   //function to sort the active list by taking the values from the symbol table based on the end point
   public void sortActiveList(){
      for(String className : symbolTable.keySet()){
         for(String methodName : symbolTable.get(className).keySet()){
            List<Variable> tempList = new ArrayList<Variable>();
            List<Variable> tempListLiveList = new ArrayList<Variable>();
            for(String varName : symbolTable.get(className).get(methodName).keySet()){
               int start = symbolTable.get(className).get(methodName).get(varName).keySet().iterator().next();
               int end = symbolTable.get(className).get(methodName).get(varName).get(start);
               tempList.add(new Variable(varName, start, end));
               tempListLiveList.add(new Variable(varName, start, end));
            }
            //sort the list based on the end point, if the end is same sot with the start point
            Collections.sort(tempList, new Comparator<Variable>(){
               public int compare(Variable v1, Variable v2){
                  if(v1.end == v2.end){
                     return v1.start - v2.start;
                  }
                  return v1.end - v2.end;
               }
            });
            // Collections.sort(tempList, new Comparator<Variable>(){
            //    public int compare(Variable v1, Variable v2){
            //       return v1.end - v2.end;
            //    }
            // });
            if(!activeListSortedEndInt.containsKey(className)){
               activeListSortedEndInt.put(className, new HashMap<String, List<Variable>>());
            }
            if (!activeListSortedEndInt.get(className).containsKey(methodName)) {
               activeListSortedEndInt.get(className).put(methodName, new ArrayList<Variable>());
            }
            // activeListSortedEndInt.get(className).put(methodName, tempList);
            if (tempList.size() > 0) {
               // activeListSortedEndInt.get(className).get(methodName).add(tempList.get(0));
               activeListSortedEndInt.get(className).get(methodName).addAll(tempList);
            }

            //sort the liveinterval list based on start point
            Collections.sort(tempListLiveList, new Comparator<Variable>(){
               public int compare(Variable v1, Variable v2){
                  if(v1.start == v2.start){
                     return v1.end - v2.end;
                  }
                  return v1.start - v2.start;
               }
            });
            if(!liveInterval.containsKey(className)){
               liveInterval.put(className, new HashMap<String, List<Variable>>());
            }
            if (!liveInterval.get(className).containsKey(methodName)) {
               liveInterval.get(className).put(methodName, new ArrayList<Variable>());
            }
            // liveInterval.get(className).put(methodName, tempList);
            if (tempListLiveList.size() > 0) {
               // liveInterval.get(className).get(methodName).add(tempListLiveList.get(0));
               liveInterval.get(className).get(methodName).addAll(tempListLiveList);
            }

         }
      }
   }

   public void sortLiveActive(){
      // for(String className : symbolTable.keySet()){
      //    for(String methodName : symbolTable.get(className).keySet()){
         String className = currentClass.peek();
         String methodName = currentMethod.peek();
            List<Variable> tempList = new ArrayList<Variable>();
            List<Variable> tempListLiveList = new ArrayList<Variable>();
            for(String varName : symbolTable.get(className).get(methodName).keySet()){
               int start = symbolTable.get(className).get(methodName).get(varName).keySet().iterator().next();
               int end = symbolTable.get(className).get(methodName).get(varName).get(start);
               tempList.add(new Variable(varName, start, end));
               tempListLiveList.add(new Variable(varName, start, end));
            }
            //sort the list based on the end point, if the end is same sot with the start point
            Collections.sort(tempList, new Comparator<Variable>(){
               public int compare(Variable v1, Variable v2){
                  if(v1.end == v2.end){
                     return v1.start - v2.start;
                  }
                  return v1.end - v2.end;
               }
            });
            // Collections.sort(tempList, new Comparator<Variable>(){
            //    public int compare(Variable v1, Variable v2){
            //       return v1.end - v2.end;
            //    }
            // });
            if(!activeListSortedEndInt.containsKey(className)){
               activeListSortedEndInt.put(className, new HashMap<String, List<Variable>>());
            }
            if (!activeListSortedEndInt.get(className).containsKey(methodName)) {
               activeListSortedEndInt.get(className).put(methodName, new ArrayList<Variable>());
            }
            // activeListSortedEndInt.get(className).put(methodName, tempList);
            if (tempList.size() > 0) {
               // activeListSortedEndInt.get(className).get(methodName).add(tempList.get(0));
               activeListSortedEndInt.get(className).get(methodName).addAll(tempList);
            }

            //sort the liveinterval list based on start point
            Collections.sort(tempListLiveList, new Comparator<Variable>(){
               public int compare(Variable v1, Variable v2){
                  if(v1.start == v2.start){
                     return v1.end - v2.end;
                  }
                  return v1.start - v2.start;
               }
            });
            if(!liveInterval.containsKey(className)){
               liveInterval.put(className, new HashMap<String, List<Variable>>());
            }
            if (!liveInterval.get(className).containsKey(methodName)) {
               liveInterval.get(className).put(methodName, new ArrayList<Variable>());
            }
            // liveInterval.get(className).put(methodName, tempList);
            if (tempListLiveList.size() > 0) {
               // liveInterval.get(className).get(methodName).add(tempListLiveList.get(0));
               liveInterval.get(className).get(methodName).addAll(tempListLiveList);
            }

      //    }
      // }
   }

   //print the active list
   public void printActiveList(){
      for(String className : activeListSortedEndInt.keySet()){
         for(String methodName : activeListSortedEndInt.get(className).keySet()){
            System.out.println("Class: " + className + " Method: " + methodName);
            for(Variable var : activeListSortedEndInt.get(className).get(methodName)){
               System.out.println("Var: " + var.varName + " Start: " + var.start + " End: " + var.end);
            }
         }
      }
   }

   //function to allocate the register
   public void lsra(){
      sortLiveActive();
      active = new ArrayList<Variable>();
      String className = currentClass.peek();
      String methodName = currentMethod.peek();
      // System.out.println(registerAllocatedVariables);
      // for(String className1 : registerAllocatedVariables.keySet()){
      //    for(String methodName1 : registerAllocatedVariables.get(className1).keySet()){
      //       for(RegisterVariable var : registerAllocatedVariables.get(className1).get(methodName1)){
      //          System.out.println("Class: " + className + " Method: " + methodName1);
      //          System.out.println("Var: " + var.varName + " Start: " + var.start + " End: " + var.end + " Reg: " + var.regAlloc);
      //       }
      //    }
      // }

      //reset all the registers
      for(int i=0; i<regLimit; i++){
         Register.put(i, false);
      }
      for (Variable variable : liveInterval.get(className).get(methodName)) {
         // System.out.println("Variable: " + variable.varName + " Start: " + variable.start + " End: " + variable.end);
         ExpireOldIntervals(variable);
         if (active.size() == regLimit) {
            SpillAtInterval(variable);
         } else {
            //Register allocation
            for (int i = 0; i < regLimit; i++) {
               if (!Register.get(i)) {
                  Register.put(i, true);
                  variable.allocatedReg = i;
                  active.add(variable);

                  Collections.sort(active, new Comparator<Variable>(){
                     public int compare(Variable v1, Variable v2){
                        return v1.end - v2.end;
                     }
                  });
                  
                  //Add the variable to the register allocated variables
                  if (!registerAllocatedVariables.containsKey(className)) {
                     registerAllocatedVariables.put(className, new HashMap<String, ArrayList<RegisterVariable>>());
                  }
                  if (!registerAllocatedVariables.get(className).containsKey(methodName)) {
                     registerAllocatedVariables.get(className).put(methodName, new ArrayList<RegisterVariable>());
                  }
                  registerAllocatedVariables.get(className).get(methodName).add(new RegisterVariable(variable.varName, variable.start, variable.end, variable.allocatedReg));
                  // check the register allocated variables
                  // System.out.println(registerAllocatedVariables.get(className).get(methodName).size());
                  break;

               }
            }
         }
         
      }
   }

   public void ExpireOldIntervals(Variable variable){
      for (int i = 0; i < active.size(); i++) {
         if (active.get(i).end >= variable.start) {
            return;
         }
         Register.put(active.get(active.get(i).allocatedReg).allocatedReg, false);
         active.remove(i);
      }
   }

   public void SpillAtInterval(Variable variable){
      Variable spill = active.get(active.size() - 1);
      if (spill.end > variable.end) {
         variable.allocatedReg = spill.allocatedReg;

         //remove the spilled variable from the register allocated variables by finding the varName in the registerAllocatedVariables
         for (int i = 0; i < registerAllocatedVariables.get(currentClass.peek()).get(currentMethod.peek()).size(); i++) {
            if (registerAllocatedVariables.get(currentClass.peek()).get(currentMethod.peek()).get(i).varName.equals(spill.varName)) {
               registerAllocatedVariables.get(currentClass.peek()).get(currentMethod.peek()).remove(i);
               break;
            }
         }
         //add the variable to the register allocated variables
         registerAllocatedVariables.get(currentClass.peek()).get(currentMethod.peek()).add(new RegisterVariable(variable.varName, variable.start, variable.end, variable.allocatedReg));

         if (!spilledVariables.containsKey(currentClass.peek())) {
            spilledVariables.put(currentClass.peek(), new HashMap<String, ArrayList<SpilledVariable>>());
         }
         if (!spilledVariables.get(currentClass.peek()).containsKey(currentMethod.peek())) {
            spilledVariables.get(currentClass.peek()).put(currentMethod.peek(), new ArrayList<SpilledVariable>());
         }
         if (spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()==0){
            spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).add(new SpilledVariable(spill.varName, spill.start, spill.end, 0, symbolTableType.get(currentClass.peek()).get(currentMethod.peek()).get(spill.varName)));
            // System.out.println("Spilled Variable: " + spill.varName + " Start: " + spill.start + " End: " + spill.end + " Spill: " + spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(0).spillLocation);
         }
         else{
            //check if the variable is already spilled
            int iterations = 0;
            for (int i = 0; i < spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size(); i++) {
               if (spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(i).varName.equals(spill.varName)) {
                  break;
               }
               iterations++;
            }
            if(iterations == spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()){
               spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).add(new SpilledVariable(spill.varName, spill.start, spill.end, spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()-1).spillLocation+1, symbolTableType.get(currentClass.peek()).get(currentMethod.peek()).get(spill.varName)));
               // System.out.println("Spilled Variable: " + spill.varName + " Start: " + spill.start + " End: " + spill.end + " Spill: " + spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()-1).spillLocation);
            }
            // System.out.println("Spilled Variable: " + spill.varName + " Start: " + spill.start + " End: " + spill.end + " Spill: " + spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()-1).spillLocation);
         }
         active.remove(active.size() - 1);
         active.add(variable);

         Collections.sort(active, new Comparator<Variable>(){
            public int compare(Variable v1, Variable v2){
               return v1.end - v2.end;
            }
         });

      } else {
         if (!spilledVariables.containsKey(currentClass.peek())) {
            spilledVariables.put(currentClass.peek(), new HashMap<String, ArrayList<SpilledVariable>>());
         }
         if (!spilledVariables.get(currentClass.peek()).containsKey(currentMethod.peek())) {
            spilledVariables.get(currentClass.peek()).put(currentMethod.peek(), new ArrayList<SpilledVariable>());
         }
         if (spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()==0){
            // System.out.println("First time spilled "+ variable.varName); 
            spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).add(new SpilledVariable(variable.varName, variable.start, variable.end, 0, symbolTableType.get(currentClass.peek()).get(currentMethod.peek()).get(variable.varName)));
            // System.out.println("Spilled Variable: " + variable.varName + " Start: " + variable.start + " End: " + variable.end + " Spill: " + spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(0).spillLocation);
         }
         else{
            //check if the variable is already spilled
               spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).add(new SpilledVariable(variable.varName, variable.start, variable.end, spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()-1).spillLocation+1, symbolTableType.get(currentClass.peek()).get(currentMethod.peek()).get(variable.varName)));
               // System.out.println("Spilled Variable: " + variable.varName + " Start: " + variable.start + " End: " + variable.end + " Spill: " + spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).get(spilledVariables.get(currentClass.peek()).get(currentMethod.peek()).size()-1).spillLocation);
         }
      }
   }

   //function to spill the variable
   public GJDepthFirst_v1(HashMap<Node, Set<String>> r) {
      resultMap = r;
   }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> <REGLIMIT>
    * f1 -> MainClass()
    * f2 -> ( TypeDeclaration() )*
    * f3 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      //take the reglimit and store it in the regLimit variable
      String reg_read = n.f0.toString();
      regLimit = Integer.parseInt(reg_read.replaceAll("[^0-9]", ""));  
      for(int i=0; i<regLimit; i++){
         Register.put(i, false);
      }
      
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

      //find the unique registers used
      for(String className : registerAllocatedVariables.keySet()){
         for(String methodName : registerAllocatedVariables.get(className).keySet()){
            //set to store the unique registers used
            Set<Integer> uniqueReg = new HashSet<Integer>();
            for(RegisterVariable var : registerAllocatedVariables.get(className).get(methodName)){
               uniqueReg.add(var.regAlloc);
            }
            if(!uniqueRegisters.containsKey(className)){
               uniqueRegisters.put(className, new HashMap<String, Integer>());
            }
            if(!uniqueRegisters.get(className).containsKey(methodName)){
               uniqueRegisters.get(className).put(methodName, uniqueReg.size());
            }
            uniqueRegisters.get(className).put(methodName, uniqueReg.size());
         }
      }

      // System.out.println(symbolTable);
      // sortActiveList();
      // System.out.println(activeListSortedEndInt);
      // printActiveList();
      // System.out.println(symbolTableType);
      
      // //print the register allocated variables
      // System.out.println("\nAllocated registers infomration starts here");
      // for(String className : registerAllocatedVariables.keySet()){
      //    for(String methodName : registerAllocatedVariables.get(className).keySet()){
      //       for(RegisterVariable var : registerAllocatedVariables.get(className).get(methodName)){
      //          System.out.println("Class: " + className + " Method: " + methodName);
      //          System.out.println("Var: " + var.varName + " Start: " + var.start + " End: " + var.end + " Reg: " + var.regAlloc);
      //       }
      //    }
      // }
      // System.out.println("Allocated registers infomration ends here\n");

      //print the spilled variables
      // for(String className : spilledVariables.keySet()){
      //    for(String methodName : spilledVariables.get(className).keySet()){
      //       for(SpilledVariable var : spilledVariables.get(className).get(methodName)){
      //          System.out.println("Class: " + className + " Method: " + methodName);
      //          System.out.println("Var: " + var.varName + " Start: " + var.start + " End: " + var.end + " Spill: " + var.spillLocation);
      //       }
      //    }
      // }

      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> ( VarDeclaration() )*
    * f15 -> ( Statement() )*
    * f16 -> "}"
    * f17 -> "}"
    */
   public R visit(MainClass n, A argu) {

      //add the main class to the stack
      currentClass.push(n.f1.f0.toString());
      //add the main method to the stack
      currentMethod.push("main");
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);
      n.f13.accept(this, argu);
      n.f14.accept(this, argu);
      n.f15.accept(this, argu);
      n.f16.accept(this, argu);
      n.f17.accept(this, argu);

      //call the lsra function to allocate the registers and spill the variables
      lsra();

      //remove the main method from the stack
      currentMethod.pop();
      //remove the main class from the stack
      currentClass.pop();
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n, A argu) {
      R _ret=null;
      //add the class to the stack
      currentClass.push(n.f1.f0.toString());

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);

      //remove the class from the stack
      currentClass.pop();
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n, A argu) {
      R _ret=null;
      //add the class to the stack
      currentClass.push(n.f1.f0.toString());
      
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);

      //remove the class from the stack
      currentClass.pop();
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n, A argu) {
      R _ret=null;



      //add the currnt variable to the symbol table with their class, method, varname, and {0,0} initial live interval
      if(!symbolTable.containsKey(currentClass.peek())){
         symbolTable.put(currentClass.peek(), new HashMap<String, HashMap<String,HashMap<Integer,Integer>>>());
      }
      if(!symbolTable.get(currentClass.peek()).containsKey(currentMethod.peek())){
         symbolTable.get(currentClass.peek()).put(currentMethod.peek(), new HashMap<String,HashMap<Integer,Integer>>());
      }
      if(!symbolTable.get(currentClass.peek()).get(currentMethod.peek()).containsKey(n.f1.f0.toString())){
         symbolTable.get(currentClass.peek()).get(currentMethod.peek()).put(n.f1.f0.toString(), new HashMap<Integer,Integer>());
         symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(n.f1.f0.toString()).put(0,0);
      }
     
      //add the current variable to the symbol table with their class, method, varname, and type
      if(!symbolTableType.containsKey(currentClass.peek())){
         symbolTableType.put(currentClass.peek(), new HashMap<String, HashMap<String,String>>());
      }
      if(!symbolTableType.get(currentClass.peek()).containsKey(currentMethod.peek())){
         symbolTableType.get(currentClass.peek()).put(currentMethod.peek(), new HashMap<String,String>());
      }
      if(!symbolTableType.get(currentClass.peek()).get(currentMethod.peek()).containsKey(n.f1.f0.toString())){
         symbolTableType.get(currentClass.peek()).get(currentMethod.peek()).put(n.f1.f0.toString(), getTypeName(n.f0));}
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      
      return _ret;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Identifier()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n, A argu) {
      R _ret=null;
      //add the method to the stack
      currentMethod.push(n.f2.f0.toString());
      
      
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      n.f7.accept(this, argu);
      n.f8.accept(this, argu);
      n.f9.accept(this, argu);
      n.f10.accept(this, argu);
      n.f11.accept(this, argu);
      n.f12.accept(this, argu);

      // System.out.println(resultMap.get(n));
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }

      this.programPoint++;

      //call the lsra function to allocate the registers and spill the variables
      lsra();
    
      //remove the method from the stack
      currentMethod.pop();
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | FloatType()
    *       | Identifier()
    */
   public R visit(Type n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "float"
    */
   public R visit(FloatType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | FieldAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    *       | LivenessQueryStatement()
    */
   public R visit(Statement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   public R visit(AssignmentStatement n, A argu) {
      

      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);

    

      
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Identifier()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n, A argu) {
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);

      

      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Identifier()
    * f5 -> ";"
    */
   public R visit(FieldAssignmentStatement n, A argu) {
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IfthenElseStatement()
    *       | IfthenStatement()
    */
   public R visit(IfStatement n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(IfthenStatement n, A argu) {
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;R _ret=null;

      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfthenElseStatement n, A argu) {
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      n.f6.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n, A argu) {
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n, A argu) {
      
      for (String varString : resultMap.get(n)) {
         if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,this.programPoint);
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
            
         }
         else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
            symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
         }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <SCOMMENT1>
    * f1 -> <LIVENESSQUERY>
    * f2 -> <SCOMMENT2>
    */
   public R visit(LivenessQueryStatement n, A argu) {
      
      if (!currentClass.isEmpty() && !currentMethod.isEmpty()) {
         
         for (String varString : resultMap.get(n)) {
            if (symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1 && symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).containsKey(0)) { 
               symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(this.programPoint,0);
               symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).remove(0);
               
            }
            else if(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().size() == 1){
                  symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).put(symbolTable.get(currentClass.peek()).get(currentMethod.peek()).get(varString).keySet().iterator().next(),this.programPoint);
               }
            }
      }
      this.programPoint++;

      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    *       | AndExpression()
    *       | CompareExpression()
    *       | neqExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | DivExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "&&"
    * f2 -> Identifier()
    */
   public R visit(AndExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "||"
    * f2 -> Identifier()
    */
   public R visit(OrExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "<="
    * f2 -> Identifier()
    */
   public R visit(CompareExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "!="
    * f2 -> Identifier()
    */
   public R visit(neqExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "+"
    * f2 -> Identifier()
    */
   public R visit(PlusExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "-"
    * f2 -> Identifier()
    */
   public R visit(MinusExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "*"
    * f2 -> Identifier()
    */
   public R visit(TimesExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "/"
    * f2 -> Identifier()
    */
   public R visit(DivExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Identifier()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ArgList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      n.f5.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> ( ArgRest() )*
    */
   public R visit(ArgList n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> Identifier()
    */
   public R visit(ArgRest n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | FloatLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    */
   public R visit(PrimaryExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <FLOAT_LITERAL>
    */
   public R visit(FloatLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Identifier()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "!"
    * f1 -> Identifier()
    */
   public R visit(NotExpression n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      return _ret;
   }

}
